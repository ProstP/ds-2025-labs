# PA6. Сегментирование базы данных

**Цель:** научиться выполнять горизонтальное масштабирование базы данных путём сегментирования (_англ._ sharding).

# Задание

## Страны и регионы

*Задание делается на базе задания PA4*

В системе появляется новый атрибут "Страна гражданства", при этом каждая страна относится к определённому региону.

- На странице ввода текста добавляется поле ввода (Dropdown List) для указания страны пользователя.
- Для каждого региона юрисдикции нужно создать выделенный сервер СУБД
- Данные должны сохраняться в СУБД региона, к которому относится страна, выбранная пользователем

Пользователь должен иметь возможность выбрать страну из следующего списка 5 стран, распределённых по трём регионам:

| Страна  | Регион |
| ------- | ------ |
| Russia  | RU     |
| France  | EU     |
| Germany | EU     |
| UAE     | ASIA   |
| India   | ASIA   |

## Сегментирование Redis

Для сегментирования базы данных следует создать несколько дополнительных экземпляров Redis, не связанных друг с другом непосредственно (то есть они **не** объединяются в Redis Cluster).

- Параметры соединения с основной БД будут передаваться через переменную окружения (*Environment Variable*) в формате `DB_MAIN={host:port}`
- Параметры соединения к серверам отдельных сегментов будут передаваться через переменные окружения в формате *DB_{REGION}={host:port}*

Например:

```bash
DB_MAIN=localhost:6000
DB_RU=localhost:6001
DB_EU=localhost:6002
DB_ASIA=localhost:6003
```

- Код региона страны, выбранной пользователем, должен использоваться для выбора сегмента (то есть используется как ShardKey)
- Центральная база данных `DB_MAIN` должна хранить только соответствие ID текста и ShardKey (то есть карту сегментирования, _англ._ Shard Map)
- Все остальные данные должны храниться в соответствующем сегменте (RU, EU или ASIA)
- При любой обработке текста с указанным ID компонент сначала находит код сегмента, а затем работает с данными сегмента

## Логирование

В каждом компоненте, который обращается к БД по заданному ID текста, должен выводиться лог в формате:

`LOOKUP: {идентификатор текста},  {идентификатор сегмента}*`

Например: 

`LOOKUP: 9B2FA05D-C54D-427F-B443-2B912D96AAA6, RUS`

# Справка по сегментированию

## О масштабировании хранилища

Централизованное хранилище данных в системах, оперирующих большим объёмом данных, сталкивается со следующими ограничениями:

1. Ограниченный объём хранилища
2. Ограниченные вычислительные ресурсы
3. Ограниченная пропускная способность сети
4. Региональные особенности работы с данными.

Вертикальное масштабирование дискового пространства, процессорных мощностей и пропускной способности сетевых соединений способно отложить на некоторое время проблемы с вышеуказанными ограничениями (но вопросы региональных особенностей функционирования при этом по прежнему остаются).

- Одним из способов решения проблем с ограничениями является разбиение данных на сегменты и размещение сегментов на отдельных серверах БД.
- Сегментирование относится к горизонтальному виду масштабирования, т.к. все сегменты имеют идентичную структуру и предназначение.
- Необходимо иметь ввиду, что сегменты являются виртуальными единицами разбиения, и на одном физическом сервере можно (и обычно так делается) разместить несколько сегментов данных.
- Сегментирование часто называют *шардингом*, а сегменты соответственно *шардами* (*shard*).

Для организации сегментирования данных необходимо:

1. Выбрать атрибут данных, по которому будет определяться принадлежность сегменту. Этот атрибут будет являться ключом сегментирования (*ShardKey*).
2. Выбрать стратегию сегментирования. Стратегия сегментирования может быть реализована как в приложении, так и непосредственно в хранилище данных, если оно поддерживает прозрачность распределения данных.

## Стратегии сегментирования

### Стратегия поиска (shard map)

Обеспечивает максимальный контроль над настройкой и использованием сегментов.

- Стратегия основана на карте сопоставления данных определённым сегментам (*ShardMap*).
- Из-за необходимости постоянного обращения к данной карте этап поиска для маршрутизации запросов создаёт дополнительные накладные расходы.

### Стратегия диапазонов

Легко реализуется, не вносит дополнительных существенных накладных расходов, поэтому работает быстро.

- Подходит в случае, если множество значений ключа сегментирования можно разбить на диапазоны.
- Например, это может быть дата создания заказа, числовой идентификатор сущности и т.д.
- Основной недостаток: стратегия не позволяет обеспечить оптимальную балансировку между сегментами в случае, если данные по диапазону распределены неравномерно, т.е. один диапазон может содержать большое количество записей (*быть перегретым*), другой быть сильно разреженным.

### Стратегия хеширования

Быстрый алгоритм, позволяющий  равномерно распределять данные и нагрузку по сегментам в случае хорошей хэш-функции.

- По сравнению с другими методами, процесс перераспределения сегментов (resharding) более сложен
- Типовое решение проблемы перераспределения сегментов — Consistent Hashing
- Существуют альтернативные решения — например, Redis Cluster использует собственное решение, названное Hash Slots

### Ссылки

1. [Sharding pattern / Microsoft Learn](https://docs.microsoft.com/en-us/azure/architecture/patterns/sharding)
2. [Теория шардирования / Habr](https://habr.com/ru/companies/oleg-bunin/articles/433370/)
3. [Redis cluster tutorial](https://redis-doc-test.readthedocs.io/en/latest/topics/cluster-tutorial/)
